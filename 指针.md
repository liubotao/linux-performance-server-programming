## 指针


### 内存和地址

我们前面提到过,我们可以把计算机内存看成是一条长街上的一排房屋.每座房子可以容纳数据,并且通过一个房号来标识。  
  
这个比喻颇为有用但是也存在局限性。计算机的内存由数以亿计的位(bit)组成，每一个位可以容纳0或者1.由于一个位所能表示的值的返回太有限，所有单独的位作用不大，通常许多位合成一组作为一个单元，这样可以存储范围较大的值。下面表示类现实机器中一些内存位置。
  
  100 101 102 103 104 105 106 107
  
这些位置的每一个都被称为字节(byte),每个字节包含了存储一个字符是需要的位数。在许多现在的机器每一个字节包含8个位，可以存储无符号0至255，或者有符号-128到127.上面这个图并没有显示这些位置的内容，但内存中的每个位置总包含一些值。每个字节通过地址来表示，如上图上面的数字表示。  

为了存储更大的值吗，我们把二个或者更多的字节合并在一起作为更大的内存单位，例如，许多机器以字为单位存储整数，每个字一般由2个或者4个字节组成。下面表示内存位置与上图相同，但是它以4个字节的字来表示  

100        104   
由于它们包含了更多的位，每个子可以容纳的无符号类型范围从0到2的32次方-1可以容纳有符号整数范围从-2的31次方到231次方-1.  
注意，尽管一个字包含4个字节，但它仍然只有一个地址。至于它的地址是它最左边的字节还是最右边那个字节的位置，不同的机器有不同的规定。另一个需要注意的硬件事项是边界对其。在要求边界对其的机器上，整型值存储的起始位置只能是某些特定的字节，通常是2或者4的倍数。但是这些问题是硬件设计者的问题，它们很少影响C程序员。我们只对二件事情有兴趣:  

1.  内存中每一个位置由一个独一无二的地址标识  
2.  内存中每一个位置包含一个值  

#### 地址与内容  

这里有另外一个例子，这次显示了内存中5个字的内容。   

100（112） 104（-1） 108（1078523331） 112（100） 116（108）  

这里显示了5个整数，每一个位于自己的字中。如果你记住一个值的存储地址，你以后可以根据这个地址获取这个值。  
但是要记住这些地址实在是太笨拙了，所有高级程序语言所能提供的特征之一就是通过名字而不是地址来访问内存的位置。下面这张图与上图相同，但是这次使用名字来代替地址   

a（112） b（-1） c（1078523331） d（100） e（108）  

当然,这些名字就是我们所称的变量。有一点非常重要，你必须记住，名字与内存位置之间的管理并不是硬件所提供的，他是由编译器为我们实现的。所以这些变量给了我们一种更方便的方法记住地址--硬件依然通过地址访问内存位置。  


#### 值和类型

现在让我们看一下存储这些位置的值。头二个位置所存储的是整数。第三个位置所存储的是一个非常大的整数，第4，5个位置存储的也是整数。下面这些变量的声明:   

    int a = 112, b = -1;
    float c = 3.14;
    int *d = &a;
    float *e  = &c;
    
 在这些声明中,变量a和b确实用于存储整型值。但是，它声明c所存储的是浮点值。可是，在上图中c的值确实一个整数。那么他们到底应该是哪一个呢？整形还是浮点型？  
 答案是该变量包含了一系列内容为0或者1的位。他们可以被解释为整数，也可以被解释为浮点数，这取决于他们使用的方式。如果使用的是整型算术指令，这个值被解释为整数，如果使用的是浮点型指令，它就是浮点数。  
 这个事实引出了一个非常重要的结论:不能简单的通过检查一个值的位来判断它的类型。为了判断值的类型（以及它的值），你必须观察程序中这个值的使用方式。考虑下面这个以二进制表示的32位值：  
 
01100111011011000110111101100010  

下面这个位可以被解释的许多结果中的几种。这些值都是从一个基于68000的处理器上面得到，如果换一个系统，使用不同的数据格式和指令，对这些位的解释将又有所不同。  

    类型             值
    1个32位整数     1735159650
    2个16位整数     26476和28514
    4个字符         glob
    浮点型          1.116533x10的24次方
    机器指令         beg.+110和ble.+102
    
这里，一个单一的值可以被解释为5个不同的类型。显然，值的类型并非值本身所固定的一种特性，而是取决于它的使用方式。因此，为了得到正确的答案，我们对值进行正确的使用是非常重要的。  
当然，编译器会帮助我们避免这些错误。如果我们将c声明为float型变量，那么当程序访问它时，编译器就会产生浮点型指令。如果我们以某种对float类型而言不适当的方式访问该变量时，编译器就会发出错误或者警告。现在看来非常明显，图中所标明值是具有误导性质的，因为它显示了c的整形表示方式。事实上真正的浮点值是3.14  

#### 指针变量的内容

让我们把话题回到指针,看看变量d和e的声明。他们被声明为指针，并用其他变量的地址予以初始化。指针的初始化是用&操作符完成的，它用于产生操作数的内存地址  

a(112)  b(-1) c(3.14) d(100) e(108)  

d和e的内容是地址而不是整型或浮点型。事实上，从图中可以很容易看出，d的内容与a的存储地址一致，而e的内容与c的存储地址一致，这也正是我们对这二个指针进行初始化时所期望的结果。区分变量d的地址(112)和它的内容(100)是非常重要的，同时也必须意识到100这个数值用于标识其位置。  

在我们转到下一步之前我们先看一些涉及变量的表达式。

    int a = 112, b = -1;
    float c = 3.14;
    int *d = &a;
    float *e = &c;
    
 前面3个非常容易:a的值是112,b的值是-1,c的值是3.14指针变量也容易,d的值是100,e的值是108.如果你以为d和e的值分别是112和3.14，那么你就犯了一个极为常见的错误。d和e声明为指针这并不会改变这些表达式的求值方式:一个变量的值就是分配给这个变量的内存位置所存储的数值。如果你简单的认为由于d和e是指针，他们它们可以分别获取存储与位置100和108的值，那么你就错了。变量的值就是分配给该变量的内存位置所存储的数值，即使是指针变量也不例外. 
 
 #### 间接访问符号
 
 通过一个指针访问它所指向的地址的过程称为间接访问或者解引用指针。这些用于执行间接访问的操作符是单目操作符*。这里有一些demo，他们使用了前面小节里面的一些声明。
 
     表达式     右值       类型  
      a         112       int
      b        -1        int 
      c        3.14       float
      d         100        int *
      e          108       float *
      *d         112       int
      *e         3.14      float
      
d的值是100.当我们对d使用间接操作符时，它表示访问内存位置为100并查看那里的值。因此，\*d右值是112-位置100的内容，它的左值是位置100本身。  
注意上面列表中各个表达式的类型:d是一个指向整型的指针,对它进行解引用操作将产生一个整形值。类似，对float\*进行间接访问将产生一个float型值。  
正常情况下，我们并不知道编译器为每个变量所选择的存储位置，所以我们事先无法预测它们的地址。这样，当我们绘制内存中的指针图时，用实际数值标识地址是不方便的，所以大部分书籍用箭头来代替.  
但是这样会引起误解，因为箭头可能会让你误以为执行了间接访问操作，单事实上它并不一定进行这个操作。  
我们必须记住指针变量的值就是一个数字。指针并不存在内建的间接访问属性，所以除非表达式中存在间接访问操作符。

#### 未初始化和非法的指针 

下面这段代码说明了一个极为常见的错误:

    int *a;
    *a = 12;
    
这个声明创建了一个名字叫a的指针变量,后面这个赋值语句把12存储在a使指向的内存位置.  
但是这个a指向那里呢?我们声明了这个变量，但是从未对它进行初始化，所以我们没有办法预测12这个值将存储与什么地址。从这点来看，指针变量与其他变量没有区别。如果变量是静态的它会被初始化为0；但是如果变量是自动的，它根本不会被初始化.无论是那种情况,声明一个指向整形的指针都不会创建用于存储整型值的内存空间。    
所以，如果这个程序执行这个赋值操作，会发生什么情况呢？如果你运气好，a的初始值会是个非法地址，这样的赋值语句将会出错，从而终止程序。在UNIX系统中，这个错误被称为段违例或者内存错误。它提示程序试图访问一个并未分配给程序的内存位置。在一台window pc上面，对未初始化或者非法指针进行间接访问的操作是一般保护性异常的根源之一。  
对于那些要求整形必须存储于特定边界的机器而言，如果这种类型的数据在内存中的存储地址处于错误的边界上，那么对这个地址进行访问将会产生一个错误。这个错误在UXIN系统中被称为总线错误  
一个更为严重的情况:这个指针偶尔可能包含一个合法的地址。接下来很简单:位于这个位置的值会被修改，虽然你无意去修改它。但是这种类型的错误非常难以发现，因为引发错误的代码可能与先前用于操作那个值的代码完全不想干。所以，在你对指针进行间接访问之前，必须非常小心，确保他们已经被初始化。  

#### NULL指针

标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针变量为NULL，你可以给它赋一个零值。为了测试一个指针变量是否为NULL,你可以将它与零值就行比较，之所以选择零是因为一种源代码的约定。就机器内部而言,NULL指针的实际值可能与此不通。在这个情况下，编译器负责零值和内部值之间的翻译转换。  

NULL指针的概念是非常有用的，因为它给你一种方法，表示返回特定的指针目前并未指向任何东西。例如，一个用于在某个数组中查找某个特定值的函数返回一个指向查找到元素组的指针。如果该数组不包含指定条件的值，函数就返回一个NULL指针。这个技巧允许返回传达二个不通片段的信息。首先，有没有找到元素？依次，如果找到，它是那个元素？  

提示：尽管这个技巧在C程序中极为常见，但是它违反了软件工程的原则。用一个单一的值表示二种不同的意思是非常危险的事情，因为将来很容易无法弄清楚那个才是它的真正用意。在大型的程序中，这个问题更为严重，因为你不可能在头脑里面对整个设计一览无余。一种更为安全的策略是让函数返回二个独立的值：首先是一个状态值，用于提示查找是否成功；其次是一个指针，当状态值提示查找成功时，它所指向的就是查找到的元素。  

对指针进行解引用操作可以获取它所指向的值。但从定义上看，NULL指针并未指向任何东西。因此，对一个NULL指针进行解引用是非法的。在对指针进行解引用操作之前，你必须确定它并非NULL指针。  

警告:如果对一个NULL指针进行间接访问会发生什么情况呢？它的结果因编译器而异。在某些机器，它会访问内存位置为0.编译器能够确保内存位置零没有存储任何变量，但是机器并未妨碍你访问或者修改这个位置.这个行为是非常不幸的，因为程序包含一个错误,但是机器缺隐藏了它的症状,这样就会使这个错误更加难以查找.  

提示: 如果所有的指针变量能给自动初始化为NULL，那确是一件幸事，但事实并非如此，不论你的机器对解引用NULL指针这种行为作何反应，对所有的指针变量进行显式初始化是个好做法。如果你已经知道指针将会被初始化为什么地址，就把它初始化该地址，否则就把它初始化为NULL，风格良好的程序会在指针解引用之前对它进行检查，这种初始化策略可以节省大量的调试时间。  

#### 指针、间接访问和左值

涉及指针的表达式能不能作为左值？如果能，又是那些呢？对表5.1优先级进行快速查询就会发现,间接访问操作符所需要的操作数是个右值，但是这个操作符产生的结果是一个左值。让我们回到早先的例子.  

    int a;
    int *d = &a;
    
指针变量可以作左值，并不是因为他们是指针，而是他们是变量。对指针变量可以间接访问表示我们应该访问指针所指向的位置。间接访问指定了一个特定的内存位置，这样我们可以把间接访问表达式作为左值。在下面二个语句中,

  *d = 10 - *d;
  d = 10 - *d;
  
第一条语句包含了二个间接访问操作。右边的间接访问作为右值使用，所以它的值是d所指向位置所存储的值(a的值)。左边的间接访问作为左值使用,所以d所指向的位置(a)把赋值符右侧的表达式的计算结果作为它的新值。  
第二条语句是非法的，因为它表示把一个整型数量(10 -*d)存储与一个指针变量中。当我们实际使用变量类型和应该使用的变量类型不一致时，编译器会发出抱怨，帮组我们判断这种情况。这些警告和错误信息是我们的朋友，编译器通过产生这些信息向我们提供帮组尽管被迫处理这些信息是我们很不情愿干的事情，但更正这些错误确实是个好主意。在修正程序方面，让编译器告诉你那里错了比你以后自己调试程序要方便多了。调速器无法像编译器那样准确查明这些问题

#### 指针、间接访问和变量

    * &a = 25
    
  首先&操作符产生一个变量a的地址，它通常是一个指针常量(注意,使用这个指针常量我们并不需要知道它的实际值)。接着,*操作符访问其操作数所表示的地址。这个表达式中，操作数是a的地址,所以值25就存储与a中.  
  
  这条语句和简单的使用a25有什么区别吗?从功能上面来说，他们是相同的。但是它涉及了更多的操作。除非编译器知道你在干什么并丢弃额外的操作，否则这些目标代码将会更大、更慢。更糟糕的是这些额外的操作符将会使源代码的可读性变差。基于这些源于，没人会故意使用像*&a这样的表达式 
  
#### 指针常量

让我们来分析另外一个表达式。假定变量a存储与位置100.下面这条语句的作用是什么?

    *100
它看上去就是把25赋给a，因为a的位置是100所存储的变量。但是这个是错的！这条语句是非法的，因为字面值100的类型是整型，而间接访问操作只能使用与指针类型表达式。如果你确定要把25存储在位置100，你必须使用强制类型转换。  
  
    *(int *) 100 = 25
  
 强制类型转换把值100从"整型"转换为"指向整型的指针",这样对它进行间访问是合法的。如果a存储于位置100，那么这条语句就把25存储与a,但是你使用这种技巧的机会是绝无仅有的!为什么?我们前面提到过,你通常无法预测编译器会把某个特定得变量放到内存中什么位置，所以你无法预知它的地址。用&操作符得到变量地址是非常容易的，但表达式在程序执行时才进行求值，此时已经把来不及把它的结果作用字面值复制到源代码

#### 指针的指针

    int  a = 12;
    int *b = &a;
   

    
  

 
 

























